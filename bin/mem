#!/usr/bin/env python3
"""mem — personal knowledge system CLI.

Usage:
    mem init <dir>              Create a new instance
    mem run <dir> [options]     Run the topics pipeline
    mem reseed <dir> [--yes]    Clear and re-seed topics DB
    mem regenerate-prompt <dir> Generate routing prompt from real topic examples
    mem upgrade <dir>           Reinstall tool wrappers (e.g. after new tools added)
"""

import os
import subprocess
import sys
from pathlib import Path

# Add the mem repo root to the Python path
MEM_ROOT = Path(__file__).resolve().parent.parent
sys.path.insert(0, str(MEM_ROOT))


def cmd_init(args):
    from pipeline import config
    from pipeline.mem_init import guided_init
    instance_dir = Path(args[0]).expanduser().resolve()
    guided_init(instance_dir)
    if (instance_dir / "config.json").exists():
        cmd_upgrade(args)


def cmd_run(args):
    from pipeline import config
    instance_dir = Path(args[0]).expanduser().resolve()
    config.init(instance_dir)

    from pipeline.topics_pipeline import main as pipeline_main
    pipeline_main(args[1:])


def cmd_reseed(args):
    from pipeline import config
    instance_dir = Path(args[0]).expanduser().resolve()
    config.init(instance_dir)

    skip_confirm = "--yes" in args or "-y" in args
    from pipeline.reseed_topics import reseed
    reseed(skip_confirm=skip_confirm)


def cmd_regenerate_prompt(args):
    from pipeline import config
    instance_dir = Path(args[0]).expanduser().resolve()
    config.init(instance_dir)

    from pipeline.topics_route import generate_routing_prompt
    generate_routing_prompt()


def cmd_upgrade(args):
    from pipeline import config
    instance_dir = Path(args[0]).expanduser().resolve()
    config.init(instance_dir)

    name = config.get_user_name().lower().split()[0]
    mem_bin = MEM_ROOT / "bin" / "mem"
    tools_dir = MEM_ROOT / "tools"
    venv_python = MEM_ROOT / ".venv" / "bin" / "python3"

    # --- Install tool wrappers ---
    print("=== Installing CLI tools ===")
    for tool in sorted(tools_dir.iterdir()):
        if tool.name.startswith(".") or tool.name == "__pycache__":
            continue
        wrapper = instance_dir / f"{name}-{tool.name}"
        wrapper_content = (
            f'#!/bin/sh\n'
            f'export MEM_INSTANCE_DIR="{instance_dir}"\n'
            f'exec "{venv_python}" "{tool}" "$@"\n'
        )
        wrapper.write_text(wrapper_content)
        wrapper.chmod(0o755)
        print(f"  {wrapper.name}")
    print(f"Installed to {instance_dir}/")

    # --- Scheduled runs (launchd) ---
    label = f"com.{name}.mem-update"
    plist_path = Path(f"~/Library/LaunchAgents/{label}.plist").expanduser()
    existing = plist_path.exists()

    if "--yes" in args or "-y" in args:
        install_schedule = True
    elif "--no-schedule" in args:
        install_schedule = False
    else:
        default = "Y" if existing else "y"
        prompt = f"\nSet up daily scheduled runs? [{'Y/n' if existing else 'y/N'}] "
        answer = input(prompt).strip().lower()
        if existing:
            install_schedule = answer != "n"
        else:
            install_schedule = answer == "y"

    if not install_schedule:
        print("Skipping schedule setup.")
        return

    hour = 0
    minute = 1
    if existing:
        print(f"\nUpdating existing schedule: {plist_path}")
    elif "--yes" not in args and "-y" not in args:
        try:
            time_input = input(f"Run daily at what time? [HH:MM, default 00:01] ").strip()
            if time_input:
                parts = time_input.split(":")
                hour = int(parts[0])
                minute = int(parts[1]) if len(parts) > 1 else 0
        except (ValueError, IndexError):
            print("Invalid time, using 00:01")

    plist_content = f"""<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>{label}</string>
    <key>ProgramArguments</key>
    <array>
        <string>/bin/bash</string>
        <string>-c</string>
        <string>{mem_bin} run {instance_dir} 2&gt;&amp;1 | tee /tmp/mem-update.log</string>
    </array>
    <key>StartCalendarInterval</key>
    <dict>
        <key>Hour</key>
        <integer>{hour}</integer>
        <key>Minute</key>
        <integer>{minute}</integer>
    </dict>
    <key>StandardOutPath</key>
    <string>/tmp/mem-update.log</string>
    <key>StandardErrorPath</key>
    <string>/tmp/mem-update.err</string>
</dict>
</plist>
"""

    # Unload old plist if it exists
    if existing:
        subprocess.run(
            ["launchctl", "bootout", f"gui/{os.getuid()}", str(plist_path)],
            capture_output=True,
        )

    plist_path.write_text(plist_content)
    # Clear quarantine xattr that can break launchd
    subprocess.run(["xattr", "-d", "com.apple.provenance", str(plist_path)], capture_output=True)
    subprocess.run(["xattr", "-d", "com.apple.quarantine", str(plist_path)], capture_output=True)

    result = subprocess.run(
        ["launchctl", "bootstrap", f"gui/{os.getuid()}", str(plist_path)],
        capture_output=True, text=True,
    )
    if result.returncode == 0:
        print(f"\n=== Schedule installed ===")
        print(f"  Plist: {plist_path}")
        print(f"  Runs daily at {hour:02d}:{minute:02d}")
    else:
        print(f"\nWarning: launchctl bootstrap failed: {result.stderr.strip()}")
        print(f"  Plist written to {plist_path} — load manually with:")
        print(f"  launchctl bootstrap gui/{os.getuid()} {plist_path}")


def main():
    if len(sys.argv) < 2:
        print(__doc__)
        sys.exit(1)

    command = sys.argv[1]
    args = sys.argv[2:]

    commands = {
        "init": cmd_init,
        "run": cmd_run,
        "reseed": cmd_reseed,
        "regenerate-prompt": cmd_regenerate_prompt,
        "upgrade": cmd_upgrade,
    }

    if command in ("-h", "--help"):
        print(__doc__)
        sys.exit(0)

    if command not in commands:
        print(f"Unknown command: {command}")
        print(__doc__)
        sys.exit(1)

    if not args:
        print(f"Error: {command} requires an instance directory argument")
        sys.exit(1)

    commands[command](args)


if __name__ == "__main__":
    main()
